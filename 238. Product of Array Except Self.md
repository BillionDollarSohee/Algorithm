[리트코드 238 - 자신을 제외한 배열의 곱](https://leetcode.com/problems/product-of-array-except-self/description/)

문제 : 배열을 입력 받아 output[i]가 자신을 제외한 나머지 모든 엘리먼트의 곱셈 결과가 되도록 출력하라
단, 나눗셈을 하지 않고 O(n)에 풀이하라

입력 : [1, 3, 5, 7]
출력 : [105, 35, 21, 15]

## 자바 풀이 1. 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱하기
제약사항으로 나눗셈을 하지 않고라고 말하기 때문에 전체 값에서 자기 자신을 나눠서 푸는 방법은 사용할 수 없다.
따라서 자기 자신을 제외한 왼쪽의 곱셈 결과와 오른쪽의 곱셈 결과를 곱하는 풀이 방법 밖에 없다.

곱셈 결과는 임시변수 p에 담았다.

### 왼쪽 곱셈 과정

| i | nums\[i] | result\[i] 저장값   | p 값 갱신 과정                |
| - | -------- | ------------------- | ------------------------------ |
| 0 | 1        | result\[0] = p = 1  | p = p \* nums\[0] = 1 \* 1 = 1 |
| 1 | 3        | result\[1] = p = 1  | p = 1 \* 3 = 3                 |
| 2 | 5        | result\[2] = p = 3  | p = 3 \* 5 = 15                |
| 3 | 7        | result\[3] = p = 15 | p = 15 \* 7 = 105              |

### 오른쪽 곱셈 과정
왼쪽 곱셈이 끝난 후 result 상태는 [1, 1, 3, 15]
이 상태에서 오른쪽부터 역방향으로 누적곱을 곱해준다.

| i | nums\[i] | result\[i] 계산 전 | result\[i] \*= p 수행 결과 | p 값 갱신 과정 |
| - | -------- | --------------- | ---------------------- | ------------------ |
| 3 | 7        | result\[3] = 15 | 15 \* 1 = 15           | p = 1 \* 7 = 7     |
| 2 | 5        | result\[2] = 3  | 3 \* 7 = 21            | p = 7 \* 5 = 35    |
| 1 | 3        | result\[1] = 1  | 1 \* 35 = 35           | p = 35 \* 3 = 105  |
| 0 | 1        | result\[0] = 1  | 1 \* 105 = 105         | p = 105 \* 1 = 105 |


```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] result = new int[nums.length];

        // 왼쪽 곱셈
        int p = 1;
        for (int i = 0; i < nums.length; i++) {
            result[i] = p;
            p *= nums[i];
        }

        // 오른쪽 곱셈
        p = 1;
        for (int i = nums.length - 1; i >= 0; i--) {
            result[i] *= p;
            p *= nums[i];
        }

        return result;
    }
}
```

<img width="680" height="438" alt="image" src="https://github.com/user-attachments/assets/960c2efd-ca0e-4a6b-b863-9d4c94373c47" />

## 동일한 방식의 코틀린 풀이
코틀린에서 indices는 배열이나 리스트 같은 컬렉션의 유효한 인덱스 범위를 나타내는 속성이다.
```kotlin
val list = listOf("a", "b", "c")
println(list.indices)  // 출력: 0..2
```
따라서 `for (i in nums.indices.reversed())`는 nums 배열을 거꾸로 인덱스로 순회하는 것을 직관적인 코드로 알아챌 수 있다.


```kotlin
class Solution {
    fun productExceptSelf(nums: IntArray): IntArray {
        val result = IntArray(nums.size)

        // 왼쪽 곱셈
        var p = 1
        for (i in nums.indices) {
            result[i] = p;
            p *= nums[i]
        }

        // 오른쪽 곱셈
        p = 1
        for (i in nums.indices.reversed()) {
            result[i] *= p
            p *= nums[i]
        }

        return result
    }
}
```

<img width="682" height="438" alt="image" src="https://github.com/user-attachments/assets/418553b9-4469-40d6-8f30-02714f6e178f" />

