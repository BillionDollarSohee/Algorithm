(리트코드 1. Two Sum)[https://leetcode.com/problems/two-sum/]
문제 덧셈하여 타깃을 만들 수 있는 배열의 두 숫자 인덱스를 리턴하라.


// kotlin
```kotlin
class Solution {
    fun twoSum(nums: IntArray, target: Int): IntArray {
        val numsMap: MutableMap<Int, Int> = mutableMapOf()

        for ((i,num) in nums.withIndex()) {
            if(numsMap.containsKey(target - num)) {
                return intArrayOf(numsMap[target - num]!!, i)
            }
            // 정답이 아니므로 다음 비교를 위해 인덱스를 맵에 저장
            numsMap[num] = i
        }
        return intArrayOf(0, 0)
    }
}
```

// java 브루트 포스로 계산
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        
        for(int i = 0; i < nums.length; i++) {
            for(int j = i+1; j < nums.length; j++) {
                if(nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        //항상 정답이 존재하므로 널이 리턴되는 경우는 없음
        return null;
    }
}
```

<img width="685" height="443" alt="image" src="https://github.com/user-attachments/assets/0d2a70bc-e09a-473c-8aac-338b89aa3abd" />

// java 성능 향상 1 - 첫 번째 수를 뺀 결과 키 조회
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> numsMap = new HashMap<>();
        
        // 키와 값을 바꿔서 맵에 저장
        for (int i = 0; i < nums.length; i++) {
            numsMap.put(nums[i], i);
        }

        // 타겟에서 첫 번째 수를 뺀 결과를 키로 조회 후 현재 인덱스가 아닐 경우 정답
        for (int i = 0; i < nums.length; i++) {
            if (numsMap.containsKey(target - nums[i]) && i != numsMap.get(target - nums[i])) {
                return new int[]{i, numsMap.get(target - nums[i])};
            }
        }

        return null;
    }
}
```

<img width="681" height="440" alt="image" src="https://github.com/user-attachments/assets/5f6f7b72-a4f8-4c17-b9c9-39e4c1d39b97" />

// java 성능 향상 2 - 조회 구조 개선
for문을 1번만 돌게끔 수정

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> numsMap = new HashMap<>();
        
        for (int i = 0; i < nums.length; i++) {
            if (numsMap.containsKey(target - nums[i])) {
                return new int[]{i, numsMap.get(target - nums[i])};
            }
            // 정답이 아니므로 다음 비교를 위해 인덱스를 저장
            numsMap.put(nums[i], i);
        }

        return null;
    }
}
```


<img width="675" height="441" alt="image" src="https://github.com/user-attachments/assets/7d65b919-7e92-427b-acc9-aefe07ea02cd" />




