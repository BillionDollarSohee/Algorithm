https://leetcode.com/problems/3sum/description/

문제 : 배열을 입력받아 합으로 0을 만들 수 있는 3개의 엘리먼트를 출력하라.
입력 : nums = [-1, 0, 1, 2, -1, -5]
출력 : [[-1, 0, 1], [-1, -1, 2]]

브루트 포스로 (sort() + 3중for문)이문제를 풀면 O(n³)으로 풀 수 있어 보이지만 타임 아웃이 발생해 실패한다.
시간복잡도를 줄이기 위해 다른 방식으로 O(n²)까지는 최적화를 해야한다.

## JAVA 풀이 1.  투 포인터로 합 계산
정렬 후 i를 축으로 중복된 값은 건너뛰면서(continue) 투 포인터로 간격을 좁혀나가면서 sum을 계산한다.
합이 0보다 작다면 값을 키우기 위해 left를 우측으로 이동하고
합이 0보다 크면 값을 줄이기 위해 right를 좌측으로 이동한다.
합이 0이면 정답이며, 결과를 리스트에 담고, 같은 정답이 나오지 않도록 left를 더하고 right를 뺀다.
1개가 아닌 둘다 이동시켜야 하는 점을 생각하기가 어려울 수 있다.

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int left, right, sum;
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            left = i + 1;
            right = nums.length - 1;
            while (left < right) {
                sum = nums[i] + nums[left] + nums[right];
                if (sum < 0) {
                    left ++;
                } else if (sum > 0) {
                    right --;
                } else {
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                    // 중복 건너뛰기
                    while (left < right && nums[left] == nums[left + 1]) left ++;
                    while (left < right && nums[right] == nums[right - 1]) right --;

                    left++;
                    right--;
                }

            }
        }
        return result;
    }
}
```
결과는 엄청나게 빠르다.

<img width="678" height="440" alt="image" src="https://github.com/user-attachments/assets/9b53d3ff-8141-4dbd-be15-90d107714493" />

## 코틀린 풀이
```kotlin
class Solution {
    fun threeSum(nums: IntArray): List<List<Int>> {
        var left: Int
        var right: Int
        var sum: Int
        val result = mutableListOf<List<Int>>()
        nums.sort()

        for (i in 0 until nums.size - 2) {
            if (i > 0 && nums[i] == nums[i - 1]) continue

            var left = i + 1
            var right = nums.size - 1
            while (left < right) {
                sum = nums[i] + nums[left] + nums[right]

                when {
                    sum < 0 -> left++
                    sum > 0 -> right--
                    else -> {
                        result.add(listOf(nums[i], nums[left], nums[right]))

                        while (left < right && nums[left] == nums[left + 1]) left++
                        while (left < right && nums[right] == nums[right - 1]) right--

                        left++
                        right--
                    }
                }
            }
        }

        return result
    }
}
```

<img width="678" height="440" alt="image" src="https://github.com/user-attachments/assets/d030cd62-4d58-496c-a07a-475e1af69c22" />

자바와 동일한 방식의 코드라 그런지 코틀린으로도 속도는 엄청 빠르다.
코틀린은 가변이나 불변이냐를 중요하게 여기기 때문에 리턴타입이 MutableList가 List를 상속 받기에 가능하다.
for문이 `for(i in 0 nutil num.size -2)`이고, asList()대신 `listOf`를 사용한 것을 볼 수 있다.
