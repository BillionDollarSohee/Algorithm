[리트코드 200 - 섬의 개수](https://leetcode.com/problems/number-of-islands/description/)

문제 : 1이 육지, 0이 물인 2차원 그리드 맵이 주어졌을 때, 섬의 개수를 계산하라. (= 연결되어 있는 1의 개수) <br>
입력 : [1,1,1,1,0] <br>
입력 : [1,1,0,1,0] <br>
입력 : [1,1,0,0,0] <br>
입력 : [0,0,0,0,1] <br>

출력 : 2 <br>

## 자바풀이1. DFS로 그래프 탐색
이 문제는 쾨니히스베르크의 다리 문제처럼 그래프 모양이 아니라도 그래프로 변환하여 풀기 좋은 문제이다. <br>
해외 기업에서 자주 쓰이는 유명한 문제로, 국내 유명 소셜커머스 회사에서 화이트보드 코딩 문제로 출제된 적이 있다. <br>
입력 값이 정확히 그래프는 아니지만 동서남북이 모두 연결된 상태라고 가정하고, DFS재귀로 동서남북 각각의 탐색을 마치면, <br>
1이 증가하는 형태로 육자의 개수를 파악할 수 있다. <br>

처음에는 행과 열단위로 움직이며 육지를 찾고, 육지를 발견하면 dfs로 탐색을 시작한다. <br>
육지가 아닌 곳은 return으로 재귀 호출이 백트래킹으로 모두 빠져나오면 섬하나를 발견한 것으로 간주한다.

```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;

        // 행렬을 모두 탐색
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                // 만약 육지(1)면 DFS시작
                if (grid[i][j] == '1') {
                    dfs(i, j, grid);
                    count++;
                }
            }
        }
        return count;
    }

    public void dfs(int i, int j, char[][] grid) {
        // 현재 위치가 그리드 밖이거나, 물(0)인 경우 종료
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0') {
            return;
        }

        // 한번만 탐색하기 위해 탐색완료하면 0으로 변경
        grid[i][j] = '0';

        // 동서남북 재귀
        dfs(i, j + 1, grid); // 동
        dfs(i, j - 1, grid); // 서
        dfs(i + 1, j, grid); // 남
        dfs(i - 1, j, grid); // 북
    }
}
```

<img width="694" height="548" alt="image" src="https://github.com/user-attachments/assets/18296bfe-a318-4ea8-8d23-82e03e82127d" />
