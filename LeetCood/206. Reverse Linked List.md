역순 연결 리스트 https://leetcode.com/problems/reverse-linked-list/description/

문제 : 연결 리스트를 뒤집어라
입력 : 1 -> 2 -> 3 -> 4 -> 5 -> 6
출력 : 6 -> 5 -> 4 -> 3 -> 2 -> 1

## 자바풀이 1. 재귀 구조로 뒤집기

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(head, null);
    }

    public ListNode reverse(ListNode node, ListNode prev) {
        // 현재 노드가 null 이면 리턴
        if (node == null) {
            return prev;
        }
        ListNode next = node.next;
        node.next = prev;
        return reverse(next, node);
    }
}
```

<img width="696" height="441" alt="image" src="https://github.com/user-attachments/assets/99802a6a-b45b-4d8c-ab7a-4db03346b9dc" />

## 자바풀이 2. 반복 구조로 뒤집기

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null, node = head;
        
        while (node != null) {
            ListNode next = node.next;
            node.next = prev;
            prev = node;
            node = next;
        }

        return prev;
    }
}
```

현재 노드의 다음 노드를 미리 지정하고,
현재 노드의 다음으로 이전 노드를 지정한다.
이전노드는 현재노드로 지정하고
미리 지정했던 다음 노드를 현재 노드로 변경하는 것을 반복한다.
node가 null이 될 때, prev는 뒤집힌 연결리스트의 첫 번째 노드가 된다.

<img width="694" height="441" alt="image" src="https://github.com/user-attachments/assets/dce7697c-43cd-49be-978c-57bcdf9bffdb" />

## 코틀린풀이. 반복 구조로

```kotlin
class Solution {
    fun reverseList(head: ListNode?): ListNode? {
        var prev: ListNode? = null
        var node = head

        while (node != null) {
            val next = node.next
            node.next = prev
            prev = node
            node = next
        }

        return prev
    }
}
```

<img width="686" height="442" alt="image" src="https://github.com/user-attachments/assets/d6b892de-43bf-4488-b12c-507c7fdd72cd" />

풀이방법은 자바와 별 차이없다.
다만 노드를 선언할 때 널허용으로 ? 를 붙여야한다.

> 성능은 반복구조가 재귀에 비해 메모리를 더 적게 차지하고 실행속도도 더 빠른편이다.
하지만 재귀 풀이가 코드가 더 짧고 우아한 풀이라는 느낌을 준다.
