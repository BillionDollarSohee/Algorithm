[리트코드 21. - 두 정렬 리스트의 병](https://leetcode.com/problems/merge-two-sorted-lists/description/)

문제: 정렬되어 있는 두 연결 리스트를 합쳐라
입력: 1->2->5, 1->3->4
출력: 1->1->2->3->4->5

<img width="714" height="322" alt="image" src="https://github.com/user-attachments/assets/5c2dc120-bb4d-4764-8f47-81a77a19612c" />

## 자바풀이. 재귀구조로 연결
이 문제에서 가장 중요한 조건은 두 연결 리스트가 이미 정렬되어 있다는 점이다.
각 리스트가 정렬된 상태라면, 각 리스트의 첫 번째 값이 그 리스트에서 가장 작은 값이라는 것이 보장된다.
따라서 두 리스트를 하나로 합칠 때는 복잡하게 전체를 비교할 필요 없이, 두 리스트의 현재 첫 번째 값만 비교하면서 더 작은 값을 결과 리스트에 추가하면 된다.

이 방식은 병합 정렬(Merge Sort)의 마지막 병합 단계와 동일한 원리를 따른다.
병합 정렬에서 두 개의 정렬된 부분 리스트를 하나로 합칠 때도, 맨 앞의 값부터 차례대로 비교하면서 작은 값을 선택하는 방식으로 한 번에 정렬된 결과를 만들어 낸다.

예를 들어, 두 접시에 음식이 크기 순으로 정렬되어 쌓여 있다면, 두 접시의 맨 위 음식만 비교해서 더 작은 것부터 새로운 접시에 옮기면 전체가 자연스럽게 정렬된다.
또는, 두 줄의 사람들이 이미 키 순서대로 서 있다면, 두 줄의 맨 앞 사람만 비교하면서 더 작은 키부터 새로운 줄에 세우면 전체가 다시 정렬된 하나의 줄이 된다.
왜냐하면 각 줄의 맨 앞 사람이 그 줄에서 가장 작다는 사실이 항상 유지되기 때문이다.

결국 이 문제는 병합 정렬의 병합 단계를 그대로 구현하는 문제이며,
첫 번째 값부터 비교하며 하나씩 결과 리스트에 넣어 가면 해결된다.

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // 두 노드 중 한쪽이 널이면 널이 아닌 노드를 리턴
        if (list1 == null) return list2; 
        if (list2 == null) return list1;

        // l2가 더 크면 l1에 재귀 호출 결과를 엮고 l1을 리턴
        if (list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        } else {
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
}
```

코드가 짧고 단순해 보이지만 많은 내용이 함축되어 있고, 재귀라 이해가 까다롭다.
list1과 list2의 값을 비교하고 작은 값이 있는 쪽을 재귀 호출로 엮은 다음 다음 결과를 리턴하는 코드이다.
재귀 호출 시 엮는 쪽은 그다음 노드를 입력값으로 전달한다.
이렇게 하면 작은 쪽이 계속해서 엮이는 연결리스트가 될 것이다.
마지막으로 어느한쪽이 null이 되면 null이 아닌 노드를 리턴하면서 마무리된다.

재귀호출로 인해 엮었던 노드는 이때부터 되돌아가면서 최종 결과를 리턴한다. 이 과정을 도식화 하면,

<img width="664" height="453" alt="image" src="https://github.com/user-attachments/assets/a1610000-24c8-4f16-8ab8-7c0186a6e62e" />


<img width="692" height="444" alt="image" src="https://github.com/user-attachments/assets/cd83d880-ec70-411d-bbec-53b84e97722d" />


## 코틀린풀이.
동일한 코드를 코틀린으로 풀면 아래와 같다.
특이점은 ListNode의 맴버변수가 코틀린의 예약어와 동일하므로 백틱을 사용하였다.
또한 리턴에 if를 표현식으로 사용하였다.

```kotlin
class Solution {
    fun mergeTwoLists(list1: ListNode?, list2: ListNode?): ListNode? {
        // 두 노드 중 한쪽이 널이 아닌 노드를 리턴
        if (list1 == null) return list2;
        if (list2 == null) return list1;

        // l2가 더 크면 l1에 재귀호출 결과를 엮고 l1을 리턴
        return if (list1.`val` < list2.`val`) {
            list1.next = mergeTwoLists(list1.next, list2)
            list1
        } else {
            list2.next = mergeTwoLists(list1, list2.next)
            list2
        }
    }
}
```

<img width="683" height="444" alt="image" src="https://github.com/user-attachments/assets/8000edae-6e61-4555-bdc6-c51cc80589f4" />


