[리트코드 225. - 큐를 이용해서 스택 구현](https://leetcode.com/problems/implement-stack-using-queues/description/)

문제 : 큐를 이용해 다음 연산을 지원하는 스택을 구현하라
- push(x) : 엘리먼트 x를 스택에 삽입한다.
- pop() : 스택의 첫 번째 엘리먼트를 삭제한다.
- top() : 스택의 첫 번째 엘리먼트를 가져온다.
- empty() : 스택이 비어있는지 확인한다.

```java
해당 스택 사용 예는 다음과 같다.

MyStack stack = new MyStack();

stack.push(1);
stack.push(2);
stack.push(3);
stack.top();   // 3
stack.pop();   // 3
stack.empty(); // false
```

## 자바 풀이. push()할 때 큐를 이용해 재정렬하기
```java
// 내 풀이
class MyStack {

    Queue<Integer> queue = new LinkedList<>();
    
    public void push(int x) {
        queue.add(x);
        for (int i = 1; i < queue.size(); i++) {
            queue.add(queue.remove());
        }
    }
    
    // 재정렬한 상태이므로 큐 연산으로 추출
    public int pop() {
        return queue.remove(); 
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.size() == 0;
    }
}
```
<img width="680" height="435" alt="image" src="https://github.com/user-attachments/assets/5190b7e4-e971-47d5-a217-26b513be1149" />


```java
// chatGPT풀이

import java.util.LinkedList;
import java.util.Queue;

public class MyStack {
    private Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }
    
    public void push(int x) {
        int size = queue.size();
        queue.offer(x); // 큐 뒤에 추가
        for (int i = 0; i < size; i++) { // 기존 요소들을 모두 뒤로 이동
            queue.offer(queue.poll());
        }
    }
    
    public int pop() {
        return queue.poll(); // 큐의 맨 앞(front) 제거
    }
    
    public int top() {
        return queue.peek(); // 큐의 맨 앞(front) 확인
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
```

<img width="678" height="439" alt="image" src="https://github.com/user-attachments/assets/4deb63a2-04db-4a0f-9301-556c07e09864" />

내 풀이에서 `Queue<Integer> queue = new LinkedList<>();` 필드 선언 시 초기화한 반면에
ChatGPT 풀이에서는 필드 선언 후 생성자에서 초기화한다 `(queue = new LinkedList<>();`

또한, push 재정렬 반복 횟수에서도 차이가 있는데
내 풀이에서 실행 시 queue.size()가 변하면서 반복 횟수가 달라질 수 있지만
ChatGPT는 push 전에 사이즈를 저장해서 정확히 기존 요소만 이동하므로 안정성 측면에서 ChatGPT 풀이가 더 안전하다.

## 코틀린 풀이
코틀린은 원시형이 없기 때문에 정수를 리턴할 때 원시형을 리턴했던 자바와 달리 Int참조형을 리턴한다.

```kotlin
class MyStack() {
    val queue: Queue<Int> = LinkedList()

    fun push(x: Int) {
        queue.add(x)    
        for (i in 1 until queue.size) {
            queue.add(queue.remove())
        }
    }

    fun pop(): Int {
        return queue.remove()        
    }

    fun top(): Int {
        return queue.peek()
    }

    fun empty(): Boolean {
        return queue.size == 0   
    }

}
```
<img width="681" height="441" alt="image" src="https://github.com/user-attachments/assets/e7390c2e-5353-4d11-bb55-58e517ad39ba" />

