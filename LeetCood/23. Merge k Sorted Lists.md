[리트코드 23 - k개 정렬 리스트 병합](https://leetcode.com/problems/merge-k-sorted-lists/)

문제 : k개의 정렬된 리스트를 1개의 정렬된 리스트로 병합하라.

k가 3개인 예시 입력 : [1->4->5, 1->3->4, 2->7]
출력 : 1->1->2->3->4->4->5->7

이 문제는 꽤 까다로워보이지만 우선 순위 큐를 이용하면 쉽게 풀이가 가능하다.
위 예시로 수도 코드를 먼저 작성해 보자면,
입력으로 받은 리스트들을 반복문으로 순회하면서 연결리스트의 첫 번째 노드들을 큐에 저장한다.
그렇게 하면 리스트의 루트들인 1과 1과 2가 저장되는데, 이 중에서 가장 작은 값을 꺼내서(1이 꺼내짐) 
그 다음 노드를 다시 큐에 넣어주는 식으로 반복한다. 
큐가 모두 빌 때 까지 우선순위에 따라 가장 작은 값을 가진 노드를 추출하고 그 노드의 다음노드인 tail.next를 다시 큐에 집어 넣으면
큐와 tail 연결리스트는 아래 시뮬레이션처럼 동작할 것 이다. 

```java
q = [1,1,2]
tail = 1

q = [1,2,4]
tail = 1 -> 1

(큐에서 1 꺼냄, 다음 노드 3을 큐에 삽입)
q = [2,3,4]
tail = 1 -> 1 -> 1

(큐에서 2 꺼냄, 다음 노드 7 삽입)
q = [3,4,7]
tail = 1 -> 1 -> 2

(큐에서 3 꺼냄, 다음 노드 4 삽입)
q = [4,4,7]
tail = 1 -> 1 -> 2 -> 3

(큐에서 4 꺼냄, 다음 노드 5 삽입)
q = [4,5,7]
tail = 1 -> 1 -> 2 -> 3 -> 4

(큐에서 4 꺼냄, 다음 노드 없음)
q = [5,7]
tail = 1 -> 1 -> 2 -> 3 -> 4 -> 4

(큐에서 5 꺼냄, 다음 노드 없음)
q = [7]
tail = 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5

(큐에서 7 꺼냄, 다음 노드 없음)
q = []
tail = 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 7
```

## 자바 풀이
우선 정렬 부분부터 살펴보자면, 

Comparator의 익명 클래스로 compare(o1, o2)를 구현하는데
정렬 순서를 값은 작은 순으로 추출하게 만들었다.
```java
PriorityQueue<ListNode> pq = new PriorityQueue<>(new Comparator<ListNode>() {
    @Override
    public int compare(ListNode n1, ListNode n2) {
        if (n1.val < n2.val) {
            return -1; // n1이 더 작으면 앞에 위치
        } else if (n1.val > n2.val) {
            return 1;  // n1이 더 크면 뒤에 위치
        } else {
            return 0;  // 같으면 순서 유지
        }
    }
});
```
위 코드를 익명 클래스를 람다 표현식으로 바꾸면 성능이 더 좋아지고 코드도 간결해지는 이점이 있어서 수정하였다.

<img width="551" height="710" alt="image" src="https://github.com/user-attachments/assets/2fa29fd9-397f-4506-b4b8-0dd5d55203b0" />

그런데 컴파일 에러를 만나게 되었다.
new PriorityQueue((o1, o2) -> { ... })
여기서 제네릭 타입을 지정하지 않아서 o1, o2가 Object로 취급되고 있고 그래서 o1.val 같은 필드를 못 찾아서 발생하고 있다.

→ 해결: new PriorityQueue<ListNode>((o1, o2) -> { ... }) 처럼 제네릭 타입을 지정하기
수정 전 : priorityQueue<ListNode> q = new PriorityQueue((o1, o2) -> {
수정 후 : PriorityQueue<ListNode> q = new PriorityQueue<ListNode>((o1, o2) -> {


```java
// 최종 완성 코드

class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> q = new PriorityQueue<ListNode>((o1, o2) -> {
            if (o1.val == o2.val) {
                return 0;
            } else if (o1.val > o2.val) {
                return 1;
            } else {
                return -1;
            }
        });

        ListNode root = new ListNode(0);
        ListNode tail = root;

        for (ListNode n : lists) {  // 각 리스트의 첫 노드를 큐에 삽입
            if (n != null) {
                q.add(n);
            }
        }

        while (!q.isEmpty()) {        // 큐가 모두 빌 때까지
            ListNode node = q.poll(); // 우선순위에 따라 추출하고, 다음노드로 이동
            tail.next = node; 
            tail = tail.next;

            if (node.next != null) {  // 추출한 연결리스트의 다음 노드는 다시 큐에 저장
                q.add(node.next);
            }
        }

        return root.next;
    }
}
```

<img width="685" height="440" alt="image" src="https://github.com/user-attachments/assets/3fa82416-4b4d-4dbb-8bf5-cc15e9e6d3f7" />



## 코틀린 풀이
코틀린의 수도코드도 자바와 동일하다.
하지만 코드상으로 when 표현식을 이용하여 더 강력하고 간결해지는 이점을 얻었다.
자바의 switch구문이 특정 변수를 두고 해당 변수의 값이 일치하거나 작거나 조건에 따라 case 구문이 실행되는 데 반해,
코틀린은 변수 선언 없이 어떤 조건이든 특정 조건이 일치하면 해당 구문을 실행할 수 있어서 강력하다고 말할 수 있다.
중괄호, 멀티 라인이 아니라 줄 단위로 표현이 가능하다.

또한 Kotlin에서는 PriorityQueue를 그대로 사용하는데
Kotlin에서는val이 키워드라 backtick(\)을 반드시 붙여야 한다 (o1.`val`).
`PriorityQueue<ListNode> { o1, o2 -> o1.`val` - o2.`val` }` 

```kotlin
class Solution {
    fun mergeKLists(lists: Array<ListNode?>): ListNode? {
        val q = PriorityQueue<ListNode> { o1, o2 -> o1.`val` - o2.`val` }

        val root = ListNode(0)
        var tail = root
        
        for (n in lists) {      // 각 리스트의 첫 노드 삽입
            if (n != null) { 
                q.add(n)
            }
        }
         
        while (q.isNotEmpty()) {   //  큐가 빌 때까지 반복
            val node = q.poll()
            tail.next = node
            tail = tail.next!!

            if (node.next != null) {
                q.add(node.next)
            }
        }

        return root.next
    }
}
```

<img width="681" height="437" alt="image" src="https://github.com/user-attachments/assets/ea1bb0d5-20ed-4f5c-a672-fd111fe45066" />








