[리트코드 232. - 스택을 이용해서 큐 구현](https://leetcode.com/problems/implement-queue-using-stacks/description/)

문제 : 스택을 이용해 다음 연산을 지원하는 큐을 구현하라
- push(x) : 엘리먼트 x를 큐 마지막에 삽입한다.
- pop() : 큐의 첫 번째 엘리먼트를 제거한다.
- peek() : 큐의 첫 번째 엘리먼트를 조회온다.
- empty() : 큐가 비어있는지 여부를 리턴한다.

```java
해당 큐의 사용 예는 다음과 같다.

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.push(3);
queue.peek();  // 1
queue.pop();   // 1
queue.empty(); // false
```

## 자바풀이. 스택 2개 사용
 [리트코드 225번 큐로 스택 구현하기](https://github.com/BillionDollarSohee/Algorithm/blob/main/LeetCood/225.%20Implement%20Stack%20using%20Queues.md) 와 반대되는 문제이다.
 지난번에는 큐에 엘리먼트를 삽입하고 전체를 재정렬해서 맨 앞의 엘리먼트를 끄집어냈었다.
 그렇게 원래의 큐에 추출 결과를 덧붙여 나가는 형태로, 추가 공간 없이 풀이했다.
 그러나 이번에는 다른 문제가 있는데 아무리 추가 삭제를 반복해도 가장 **마지막**에 넣은 아이템만 넣고 빼기를 반복하는 점이다.
 그래서 이문제를 풀기 위해서는 2개의 스택이 필요하다.
 특히 pop()과 peek()는 결국 같은 데이터에 접근한다는 점을 착안하여 pop을 할 때 peek를 호출하여 한번에 처리하게끔 하였다.
 (스택을 만들 때 push가 복잡하고 pop이 간단했었는데 이번에는 반대로 push가 간단하고 pop이 복잡한 코드가 되었다.)

또한 추출 스택 output이 모두 비게 되면 삽입 스택에서 다시 집어넣도록 처리하였다.
이렇게 구현해도 추출 스택 output의 값이 텅텅 비기전까지는 다시 삽입을 하지 않기 때문에,
분할 상환 분석에 따른 시간 복잡도는 여전히 O(1)이다.

```java
import java.util.Deque;
import java.util.ArrayDeque;

public class MyQueue {
    // 삽입용 스택
    Deque<Integer> input = new ArrayDeque<>();
    // 추출용 스택
    Deque<Integer> output = new ArrayDeque<>();

    public void push(int x) {
        input.push(x);
    }

    public int pop() {
        peek();
        return output.pop();
    }

    public int peek() {
        if (output.isEmpty()) { // 추출 스택이 비어 있으면
            while (!input.isEmpty()) { // 삽입 스택이 빌 때까지
                output.push(input.pop());
            }
        }
        return output.peek(); // 가장 위 값 반환
    }

    public boolean empty() {
        return input.isEmpty() && output.isEmpty(); // 두 스택이 모두 비워져있어야 함
    }
}
```
<img width="675" height="437" alt="image" src="https://github.com/user-attachments/assets/ee674be3-3010-4579-90a2-a4ef0c7ddc28" />

## 코틀린 풀이
코틀린은 타입을 선언하지 않아도 초기값을 보고 자동으로 추론하기 때문에 선호하는 방식을 사용하면 된다.
개인적으로는 자료형을 명확하게 선언하는 방식이 가독성이 더 높다고 생각해서 선호한다.

```kotlin
val input: Deque<Int> = ArrayDeque()
val output = ArrayDeque<Int>()
```

<img width="912" height="130" alt="image" src="https://github.com/user-attachments/assets/4b5f2003-9641-4055-85d1-b7a87fadd2a9" />

다만 리트코드상의 문제인지
Kotlin 기본 패키지에도 kotlin.collections.ArrayDeque가 있고,
Java 쪽에도 java.util.Deque가 있어서 둘 다 보이게 되면
Deque 이름이 중복되었다고 컴파일러가 충돌을 말하게 되므로
Java Deque를 쓰되 java.util.Deque로 풀네임을 지정해야 했다.

```kotlin
class MyQueue {
    val input: java.util.Deque<Int> = java.util.ArrayDeque()
    val output: java.util.Deque<Int> = java.util.ArrayDeque()

    fun push(x: Int) {
        input.push(x)
    }

    fun pop(): Int {
        peek()
        return output.pop()
    }

    fun peek(): Int {
        if (output.isEmpty()) {
            while (input.isNotEmpty()) {
                output.push(input.pop())
            }
        }
        return output.peek()
    }

    fun empty(): Boolean {
        return input.isEmpty() && output.isEmpty()
    }
}
```

<img width="674" height="434" alt="image" src="https://github.com/user-attachments/assets/1c4c151b-7c21-4392-ac5b-3d25ad3cd061" />

역시 코틀린 채점방식 문제로 성능이 자바에 비해 많이 떨어져 보이지만 실제로는 자바와 동일하게 동작하므로 동일한 시간일 것이다.

