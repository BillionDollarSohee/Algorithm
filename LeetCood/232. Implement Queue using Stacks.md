[리트코드 232. - 스택을 이용해서 큐 구현](https://leetcode.com/problems/implement-queue-using-stacks/description/)

문제 : 스택을 이용해 다음 연산을 지원하는 큐을 구현하라
- push(x) : 엘리먼트 x를 큐 마지막에 삽입한다.
- pop() : 큐의 첫 번째 엘리먼트를 제거한다.
- peek() : 큐의 첫 번째 엘리먼트를 조회온다.
- empty() : 큐가 비어있는지 여부를 리턴한다.

```java
해당 큐의 사용 예는 다음과 같다.

MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.push(3);
queue.peek();  // 1
queue.pop();   // 1
queue.empty(); // false
```

## 자바풀이. 스택 2개 사용
 [리트코드 225번 큐로 스택 구현하기](https://github.com/BillionDollarSohee/Algorithm/blob/main/LeetCood/225.%20Implement%20Stack%20using%20Queues.md) 와 반대되는 문제이다.
 지난번에는 큐에 엘리먼트를 삽입하고 전체를 재정렬해서 맨 앞의 엘리먼트를 끄집어냈었다.
 그렇게 원래의 큐에 추출 결과를 덧붙여 나가는 형태로, 추가 공간 없이 풀이했다.
 그러나 이번에는 다른 문제가 있는데 아무리 추가 삭제를 반복해도 가장 **마지막**에 넣은 아이템만 넣고 빼기를 반복하는 점이다.
 그래서 이문제를 풀기 위해서는 2개의 스택이 필요하다.
 특히 pop()과 peek()는 결국 같은 데이터에 접근한다는 점을 착안하여 pop을 할 때 peek를 호출하여 한번에 처리하게끔 하였다.
 (스택을 만들 때 push가 복잡하고 pop이 간단했었는데 이번에는 반대로 push가 간단하고 pop이 복잡한 코드가 되었다.)

또한 추출 스택 output이 모두 비게 되면 삽입 스택에서 다시 집어넣도록 처리하였다.
이렇게 구현해도 추출 스택 output의 값이 텅텅 비기전까지는 다시 삽입을 하지 않기 때문에,
분할 상환 분석에 따른 시간 복잡도는 여전히 O(1)이다.

```java

```
## 코틀린 풀이
```kotlin

```
