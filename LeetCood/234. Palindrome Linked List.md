[팬린드롬 연결 리스트](https://leetcode.com/problems/palindrome-linked-list/description/)

문제 : 연결 리스트가 팰린드롬 구조인지 판별하라 

입력 : head = [1,2,2,1] 

출력 : true

## 자바 풀이 1. 스택이용
팬린드롬 여부를 판별하기 위해서는 앞뒤로 모두 추출할 수 있는 자료구조가 필요하다.
일반적인 스택은 마지막 엘리먼트만 추출가능하므로 연결리스트를 스택에 복사하여 넣은 다음에
연결 리스트를 앞에서부터 값을 조회하고, 스택은 pop()으로 뒤에서부터 조회하여 비교할 것이다.

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        Stack<Integer> stack = new Stack<>();
        
        ListNode node = head;
        while (node != null) { // 스택에 삽입
            stack.add(node.val);
            node = node.next;
        }

        while (head != null) { // 연결리스트가 빌 때까지 비교
            if(head.val != stack.pop()) {
                return false;
            }
            head = head.next;
        }

        return true;
    }
}
```
<img width="676" height="437" alt="image" src="https://github.com/user-attachments/assets/788a1cb7-28db-4bee-8d44-0b90cd0766c3" />
잘 풀리기는 하지만, Stack으로 선언하는 점도 그렇고, 성능에서도 그렇고 아쉬운 부분이 많다.

## 자바 풀이 2. 데크이용
데크는 이중 연결 리스트 자료구조로 양쪽 방향 모두 추출하는데 시간복잡도가 O(1)이 걸린다.
만약 풀이1보다 더 효율적인 방법을 찾는다면 데크를 이용해보자.

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        Deque<Integer> deque = new LinkedList<>();
        
        ListNode node = head;
        while (node != null) { // 데크에 삽입
            deque.add(node.val);
            node = node.next;
        }

        while (!deque.isEmpty() && deque.size() > 1) { // 데크가 0 이나 1개가 될때까지 비교
            if(deque.pollFirst() != deque.pollLast()) {
                return false;
            }
        }
        return true;
    }
}
```
<img width="677" height="439" alt="image" src="https://github.com/user-attachments/assets/2c1c4fd5-a53c-4583-80ed-0564624e264e" />
데크를 사용하니 훨씬 깔끔한 풀이가 되었다. 성능은 약 2배 정도 빨라졌다.

## 자바 풀이 3. 러너 이용
사실 팰린드롬의 가장 제대로 된 풀이는 러너(Runner)기법을 활용하는 것이다.
입력값이 head = [1,2,3,2,1] 인 경우에 러너의 풀이 방법을 도식화한 이미지는 아래와 같다.

![KakaoTalk_20250824_235029088](https://github.com/user-attachments/assets/037dc7a8-4d35-4a28-878a-6967532ab2b7)




## 코틀린 풀이. 데크 이용
