[팬린드롬 연결 리스트](https://leetcode.com/problems/palindrome-linked-list/description/)

문제 : 연결 리스트가 팰린드롬 구조인지 판별하라 

입력 : head = [1,2,2,1] 

출력 : true

## 자바 풀이 1. 스택이용
팬린드롬 여부를 판별하기 위해서는 앞뒤로 모두 추출할 수 있는 자료구조가 필요하다.
일반적인 스택은 마지막 엘리먼트만 추출가능하므로 연결리스트를 스택에 복사하여 넣은 다음에
연결 리스트를 앞에서부터 값을 조회하고, 스택은 pop()으로 뒤에서부터 조회하여 비교할 것이다.

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        Stack<Integer> stack = new Stack<>();
        
        ListNode node = head;
        while (node != null) { // 스택에 삽입
            stack.add(node.val);
            node = node.next;
        }

        while (head != null) { // 연결리스트가 빌 때까지 비교
            if(head.val != stack.pop()) {
                return false;
            }
            head = head.next;
        }

        return true;
    }
}
```
<img width="676" height="437" alt="image" src="https://github.com/user-attachments/assets/788a1cb7-28db-4bee-8d44-0b90cd0766c3" />

잘 풀리기는 하지만, Stack으로 선언하는 점도 그렇고, 성능에서도 그렇고 아쉬운 부분이 많다.

## 자바 풀이 2. 데크이용
데크는 이중 연결 리스트 자료구조로 양쪽 방향 모두 추출하는데 시간복잡도가 O(1)이 걸린다.
만약 풀이1보다 더 효율적인 방법을 찾는다면 데크를 이용해보자.

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        Deque<Integer> deque = new LinkedList<>();
        
        ListNode node = head;
        while (node != null) { // 데크에 삽입
            deque.add(node.val);
            node = node.next;
        }

        while (!deque.isEmpty() && deque.size() > 1) { // 데크가 0 이나 1개가 될때까지 비교
            if(deque.pollFirst() != deque.pollLast()) {
                return false;
            }
        }
        return true;
    }
}
```
<img width="677" height="439" alt="image" src="https://github.com/user-attachments/assets/2c1c4fd5-a53c-4583-80ed-0564624e264e" />

데크를 사용하니 훨씬 깔끔한 풀이가 되었다. 성능은 약 2배 정도 빨라졌다.

## 자바 풀이 3. 러너 이용
사실 팰린드롬의 가장 제대로 된 풀이는 러너(Runner)기법을 활용하는 것이다.

> 러너(Runner) 기법
러너는 연결리스트를 순회할 때 2개의 포인터를 동시에 사용하는 기법이다.
한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간위치, 길이 등을 판별할 때 유용하게 쓸 수 있다.

입력값이 head = [1,2,3,2,1] 인 경우에 러너의 풀이 방법을 도식화한 이미지는 아래와 같다.

<img width="424" height="284" alt="image" src="https://github.com/user-attachments/assets/dd7eb129-68ae-4ea9-a3c9-44f4db8f805b" />

세로는 실행순서이며, 순서에 따라 빠른러너와 느린러너를 각각 출발시키면
빠른러너가 끝에 다다를 때, 느린러너는 정확히 중간지점에 도달하게 된다.
느린러너가 중간까지 이동한 후에는 나머지 경로를 역순으로 한 연결리스트를 만들어나간다
이렇게 역순으로 된 연결리스트와 원래 리스트를 비교하며 일치하는지 확인하면 된다.

빠른 러너 fast와 느린 러너 slow 모두 초기값은 head에서 시작한다.
그후 next가 존재하지 않을 때까지 fast는 2칸씩 slow는 1칸씩 이동한다.

만약 입력값이 홀수면 느린러너가 한칸 더 앞으로 이동해 중앙 지점을 빗겨나가야 한다.
중앙에 위치한 값은 팬린드롬 체크에서 배제되어야 하기 때문이다.
이는 fast가 null이 아닌 경우로 간주될 수 있으므로, slow를 한칸 더 이동시켜 마무리한다.


```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head, slow = head;

        while(fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        if (fast != null) { // 홀수개일때 1칸 더 가도록
            slow = slow.next;
        }

        // 중간에 도달한 느린 러너를 이용하여 역순 연결리스트를 만든다
        ListNode reverse = null;
        while (slow != null) {
            ListNode next = slow.next;
            slow.next = reverse;
            reverse = slow;
            slow = next;
        }

        while (reverse != null) {
            if (reverse.val != head.val) {
                return false;
            }
            reverse = reverse.next;
            head = head.next;
        }
        return true;
    }
}
```

<img width="680" height="439" alt="image" src="https://github.com/user-attachments/assets/022036b4-4009-4e27-ad52-1cfbaec53916" />

자료형 없이 러너 기법을 활용해서인지 매우 빠르게 실행된다.
그리고 연결리스트를 그대로 사용하는만큼 우아한 방식으로 보인다.

## 코틀린 풀이. 데크 이용
러너기법을 코틀린으로 풀어도 크게 달라질 점이 없기에 데크를 사용한 풀이를 코틀린으로 바꿔보자.
자바와 달리 데크를 선언하는 부분이 다르고, val 이라는 코틀린의 예약어가 변수로서 겹치기 때문에 백틱을 사용해야 했다. 

```kotlin
class Solution {
    fun isPalindrome(head: ListNode?): Boolean {
        val deque: Deque<Int> = LinkedList()

        var node = head
        while (node != null) {
            deque.add(node.`val`)
            node = node.next
        }

        while (!deque.isEmpty() && deque.size > 1) {
            if (deque.pollFirst() != deque.pollLast()) {
                return false
            }
        }

        return true
    }
}
```

<img width="675" height="437" alt="image" src="https://github.com/user-attachments/assets/43e98880-db7b-4d85-b69c-568b3ee67bf4" />
