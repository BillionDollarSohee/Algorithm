[리트코드 316 -  중복 문자 제거 Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/description/)

문제 : 중복된 문자를 제외하고 사전식 순서로 나열하라 <br>

입력 : dbacdcbc
출력 : acdb

입력 : cbacdcbc <br>
출력 : acdb <br>

## 자바풀이. set + sort를 이용한 풀이 (실패)
```java
class Solution {
    public String removeDuplicateLetters(String s) {
        Set<Character> set = new HashSet<>();

        for (char c : s.toCharArray()) {
            set.add(c);
        }

        List<Character> list = new ArrayList<>(set);
        Collections.sort(list);

        StringBuilder sb = new StringBuilder();
        for (char c : list) {
            sb.append(c);
        }

        return sb.toString();
    }
}
```
<img width="688" height="319" alt="image" src="https://github.com/user-attachments/assets/fcfe3c33-9420-4a8b-b53b-1f5ff5c7155f" />

이 방법으로 풀었더니, 통과하지 못한 테스트 케이스들이 속출했다.
단순하게 중복을 제거하고 정렬하는 것으로는 불가하다.

이문제가 요구하는 것은 사실 **각 문자를 정확히 한 번 사용하고, 
원래 문자열의 순서를 유지하면서 사전식 최소가 되도록 고르는 것이다.**

즉, 원본 문자열 안에서
앞뒤 상대 순서는 유지해야 하고 (relative order constraint)
그 조건 안에서 가능한 가장 사전순으로 작은 문자열을 뽑아야 한다.
(하하.. 너무 까다롭다.)

## 자바풀이. 재귀를 이용한 분리 (실패)
또다른 떠오르는 풀이는 brute-force 로,
재귀를 이용해서 각 글자를 넣을지 말지를 전부 탐색해서
만들 수 있는 모든 경우를 만들고
그 후보 문자열 하나하나를 TreeSet 으로 처리해서 중복 문자를 제거하고 정렬하면
그 중에 사전순으로 가장 앞선 걸 뽑는 방식이 떠올랐지만
원본 s 길이가 몇백 글자까지 가능하면 부분 문자열 개수가 2^n 수준이라
길이가 100만 넘어가도 시간 복잡도 상 불가능하다.

## 자바풀이. 그리디를 이용한 분리 (성공)
이 문제는 최적 문자열이 도중에 뒤집히는 순간(큰 문자를 미룰 수 있을 때)이 존재하기 때문에
그 순간을 greedy 하게 잡아내서 큰 문자를 pop 하고,
뒤에 다시 등장할 수 있음을 확인한 후 나중에 다시 넣는 방식으로 풀 수 있다.

```java
import java.util.*;

class Solution {
    public String removeDuplicateLetters(String s) {

        // 각 문자의 마지막 등장 위치 기록
        Map<Character, Integer> lastPos = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            lastPos.put(s.charAt(i), i);
        }

        Set<Character> used = new HashSet<>();
        Deque<Character> stack = new ArrayDeque<>();

        // 왼쪽 → 오른쪽 스캔하면서 즉시 결정
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);

            if (used.contains(c)) continue;

            // 현재 문자보다 stack 끝 문자가 더 크고,
            // 그 stack 끝 문자가 뒤에서 또 나온다면 → 지금 빼도 된다
            while (!stack.isEmpty()) {
                char top = stack.peekLast();
                if (top > c && lastPos.get(top) > i) {
                    stack.removeLast();
                    used.remove(top);
                } else {
                    break;
                }
            }

            stack.addLast(c);
            used.add(c);
        }

        StringBuilder sb = new StringBuilder();
        for (char ch : stack) sb.append(ch);
        return sb.toString();
    }
}
```

<img width="679" height="442" alt="image" src="https://github.com/user-attachments/assets/6fddad76-19d7-4bf0-a8cc-f586c42332c4" />

풀리긴 한데 더 좋은 성능으로 푼 사람들도 많다.
어떤 방법을 쓴걸까?

## chatGPT가 푼 성능을 높인 방법
Map/Set/Deque 오버헤드를 없애고, 순수 배열 + 문자 스택으로 최적화한 버전

```java
import java.util.*;

class Solution {
    public String removeDuplicateLetters(String s) {
        char[] arr = s.toCharArray();

        // 각 문자의 마지막 등장 위치 (ASCII 가정; 충분히 넉넉하게 128)
        int[] last = new int[128];
        Arrays.fill(last, -1);
        for (int i = 0; i < arr.length; i++) last[arr[i]] = i;

        boolean[] used = new boolean[128]; // 결과에 이미 포함되었는가

        // 결과 스택을 컬렉션 대신 char[]로 구성 (최대 26글자)
        char[] stack = new char[26];
        int top = -1;

        for (int i = 0; i < arr.length; i++) {
            char c = arr[i];
            if (used[c]) continue;

            // 스택 top이 현재 문자보다 크고, 그 문자가 뒤에 다시 나오면 pop
            while (top >= 0 && stack[top] > c && last[stack[top]] > i) {
                used[stack[top]] = false;
                top--;
            }

            stack[++top] = c;
            used[c] = true;
        }

        // 스택에 쌓인 앞부분이 곧 정답
        return new String(stack, 0, top + 1);
    }
}
```

<img width="685" height="442" alt="image" src="https://github.com/user-attachments/assets/b0ce17dc-fea5-4ae1-88cc-68fdd939f1a5" />

* HashMap/HashSet/Deque → 전부 제거
* 오직 int[], boolean[], char[] 만 사용 (박싱/언박싱, 해시연산 없음)
* StringBuilder 조립 대신 new String(char[], off, len) 바로 생성

역시 대단한 녀석..

## 코틀린 풀이
```kotlin
class Solution {
    fun removeDuplicateLetters(s: String): String {
        val last = IntArray(128)
        s.forEachIndexed { i, c -> last[c.code] = i }

        val used = BooleanArray(128)
        val stack = CharArray(26)
        var top = -1

        for (i in s.indices) {
            val c = s[i]
            val ci = c.code

            if (!used[ci]) {
                while (top >= 0 &&
                    stack[top] > c &&
                    last[stack[top].code] > i) {
                    used[stack[top].code] = false
                    top--
                }
                stack[++top] = c
                used[ci] = true
            }
        }

        return String(stack, 0, top + 1)
    }
}
```

<img width="683" height="442" alt="image" src="https://github.com/user-attachments/assets/53380530-5f19-44a3-9eb9-9a2d6a74efd7" />
