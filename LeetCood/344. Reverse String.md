[리트코드 344 - 문자열 뒤집기](https://leetcode.com/problems/reverse-string/)

문자열을 뒤집는 함수를 작성하라. 입력값은 문자 배열이며, 리턴 없이 입력 배열 내부를 직접 조작하라.
**리턴 없이** 라는 조건이 조금 까다롭지만 문제1에서 처럼 시작과 끝을 스왑하여 풀 수 있다.

```java
class Solution {
    public void reverseString(char[] s) {
        int start = 0;
        int end = s.length -1;

        while (start < end) {
            char temporary = s[start]; // 임시 변수
            s[start] = s[end];
            s[end] = temporary;

            start++;
            end--;
        }
    }
}
```

![](https://velog.velcdn.com/images/soheelog/post/75dfa1f4-cbfd-434f-bbfe-cc519a47ee75/image.png)

이번에는 코틀린으로도 풀어보자.
코틀린에서는 `also()`확장 함수를 이용하면 주 객체(리시버 객체)를 변경하지 않고 그대로 반환하면서, 람다 블록 안에서 그 객체를 사용할 수 있게 해주는데 로그 출력, 변수 설정 등 부가적인 작업에 쓰인다.

| 함수      | 리턴 값   | 람다 파라미터 이름    | 사용 목적 |
| ------- | ------ | ------------- | ----- |
| `let`   | 람다의 결과 | `it` 또는 이름 지정 | 변환    |
| `also`  | 원본 객체  | `it`          | 부가 작업 |
| `apply` | 원본 객체  | `this`        | 초기화   |
| `run`   | 람다의 결과 | `this`        | 계산 수행 |
| `with`  | 람다의 결과 | `this`        | 계산 수행 |


코드는 훨씬 간결해보이고 성능도 동일하게 동작할 코드이다.

```kotlin
class Solution {
    fun reverseString(s: CharArray): Unit {
        var start = 0
        var end = s.size - 1

        while (start < end) {
            s[start] = s[end].also { s[end] = s[start] }

            start++
            end-- 
        }

    }
}
```

![](https://velog.velcdn.com/images/soheelog/post/af8c97e8-fce0-4131-a1b2-8ce0d9884f90/image.png)
