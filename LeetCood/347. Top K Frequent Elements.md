[리트코드 347 - 상위 k 빈도 엘리먼트](https://leetcode.com/problems/top-k-frequent-elements/description/)

문제 : 빈도순으로 k개의 엘리먼트를 출력하라 <br>
입력 : [1,1,1,2,2,3,4] k=2 <br>
출력 : 1,2 <br>

## 자바풀이1. 빈도수를 저장하고 빈도순으로 엘리먼트 추출
먼저 직관적인 풀이방법으로 풀어보자. <br>
해시맵에 엘리먼트와 빈도수를 저장하고 정렬을 하면되지만<br>
정렬은 `O(n log n)` 시간복잡도를 가지므로 <br>
키를 빈도수로 하여 시간복잡도를 `O(n)` 낮출 것이다. <br>

먼저 숫자별 등장 횟수를 HashMap 에 저장한다. <br>
이렇게 하면 각 숫자가 배열에서 몇 번 나왔는지 바로 확인할 수 있다. <br>
그 다음에는 등장 횟수를 기준으로 다시 분류하는데, <br>
어떤 숫자가 몇 번 등장했다면 그 등장 횟수를 key로 하고, <br>
해당 횟수에 해당하는 숫자들을 리스트에 모아 또 다른 Map 에 저장한다. <br>
예를 들어, 어떤 숫자는 3번 나왔고 어떤 숫자는 2번 나왔다면 <br>
`3번 등장한 숫자 리스트`와 `2번 등장한 숫자 리스트`로 묶이는 식이다.

이제 가장 자주 등장한 숫자를 찾기 위해, <br>
배열의 길이(최대 등장 가능 횟수)부터 1까지 역순으로 내려가면서 <br>
그 횟수에 해당하는 숫자들이 있는지 확인한다. <br>
만약 해당 횟수로 묶인 숫자 리스트가 있다면, <br>
그 리스트에 포함된 숫자를 차례대로 결과 배열에 채워 넣는다. <br>

이때 K개를 다 채웠다면 탐색을 종료한다. <br>
결국 이 알고리즘은 어떤 숫자가 얼마나 많이 등장했는지를 기준으로 <br>
가장 큰 빈도부터 확인해 나가기 때문에, <br>
따로 정렬을 하지 않아도 가장 많이 등장한 숫자 K개를 효율적으로 얻을 수 있다. <br>

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int n : nums) {
            frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);
        }

        Map<Integer, List<Integer>> buckets = new HashMap<>();
        for (int e : frequencyMap.keySet()) {
            int frequency = frequencyMap.get(e);
            List<Integer> elem = buckets.getOrDefault(frequency, new ArrayList<>());
            elem.add(e);
            buckets.put(frequency, elem);
        }

        int[] result = new int[k];
        int index = 0;
        for (int frequency = nums.length; frequency > 0 && index < k; frequency--) {
            if (buckets.containsKey(frequency)) {
                for (int e : buckets.get(frequency)) {
                    if (index < k) {
                        result[index++] = e;
                    } else {
                        break;
                    }
                }
            }
        }
        return result;
    }
}
```

<img width="685" height="391" alt="image" src="https://github.com/user-attachments/assets/2f18991e-4a68-498e-a2e1-31de3a639d45" />

## 자바풀이2. 우선순위 큐
```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int n : nums) {
            frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);
        }

        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[1] - a[1]);
        for (int elem : frequencyMap.keySet()) {
            pq.add(new int[] {elem, frequencyMap.get(elem)});
        }

        int[] result = new int[k];
        for (int i = 0; i < k; i++) {
            result[i] = pq.poll()[0];
        }
        return result;
    }
}
```


<img width="685" height="389" alt="image" src="https://github.com/user-attachments/assets/d664d843-e58a-45f9-b970-2352d7ee8620" />


## 코틀린 풀이. 우선순위 큐
```kotlin
class Solution {
    fun topKFrequent(nums: IntArray, k: Int): IntArray {
        val frequencyMap: MutableMap<Int, Int> = mutableMapOf()

        for (n in nums) {
            frequencyMap[n] = frequencyMap.getOrDefault(n, 0) + 1
        }

        val pq: PriorityQueue<IntArray> = PriorityQueue {
            a: IntArray, b: IntArray -> b[1] - a[1]
        }

        for (elem in frequencyMap.keys) {
            pq.add(intArrayOf(elem, frequencyMap[elem]!!))
        }

        val result = IntArray(k)

        for (i in 0 until k) {
            result[i] = pq.poll()[0]
        }

        return result
    }
}
```


<img width="685" height="539" alt="image" src="https://github.com/user-attachments/assets/94d1d730-9d06-42ff-8d18-7544b4f25a22" />

