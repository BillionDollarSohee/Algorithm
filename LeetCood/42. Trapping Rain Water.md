[리트코드 42 - Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)

문제. 높이를 입력 받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라.

![](https://velog.velcdn.com/images/soheelog/post/2935773a-903f-4b25-a752-1ffec912aad9/image.png)

높이와 너비를 차례대로 모두 살펴보면 O(n²)가 걸리고 시간 복잡도가 높기 때문에 좀 더 효율적인 풀이가 필요한 문제이다. 투 포인터나 스택을 활용하면 O(n)으로 가능할 것이다.

## 풀이 1. 투 포인터를 최대로 이동
그림 예시에서 가장 높은 높이는 3이지만 최대 높이가 100이여도 결과는 동일하다.
즉, 막대는 높고 낮음과 무관하고, 전체 부피에 영향을 끼치지 않으면서 그저 왼쪽과 오른쪽을 나누는 장벽 역할을 한다. 또한 인덱스 0에 물이 채워지지 않은 것을 보고 양쪽 포인터에서 시작해야 한다고 생각했다.
그러면 적어도 낮은 쪽은 물이 항상 채워질 것이기 때문에, 좌우 어느쪽이든 낮은 쪽에서 높은 쪽으로 향하여 포인터를 이동시킬 것이다. 각각의 포인터는 최대 높이를 기억하고 있으면서도, 현재와의 차이만큼 물높이를 더할 것이다. 위 예시에서는 양쪽의 포인터가 점점 가운데로 이동하다가 최대높이인 3까지 이동하다가 두 포인터가 만나게 되어 종료할 것이다.

```java
class Solution {
    public int trap(int[] height) {
        int water = 0;
        int left = 0;
        int right = height.length - 1;
        int leftMax = height[left];
        int rightMax = height[right];

        while (left < right) { // 두 포인터가 겹칠때까지
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);

            if (leftMax <= rightMax) {
                water += leftMax - height[left];
                left ++;
            } else {
                water += rightMax - height[right];
                right --;
            }
        }

        return water;
    }
}
```

![](https://velog.velcdn.com/images/soheelog/post/15f49c89-b311-47a4-bcb7-9b16c2da8f39/image.png)

### 코틀린 풀이
자바의 `Math.max()` 대신 `coerceAtLeast()` 라는 확장 함수를 쓰는 것 외엔 크게 다른점은 없다.

```kotlin
class Solution {
    fun trap(height: IntArray): Int {
        var water = 0
        var left = 0
        var right = height.size -1
        var leftMax = height[left]
        var rightMax = height[right]

        while (left < right) {
            leftMax = height[left].coerceAtLeast(leftMax)
            rightMax = height[right].coerceAtLeast(rightMax)

            if (leftMax <= rightMax) {
                water += leftMax - height[left]
                left ++
            } else {
                water += rightMax - height[right]
                right --
            }
        }

        return water
    }
}
```
![](https://velog.velcdn.com/images/soheelog/post/b56338cc-8c0d-47a1-8937-42c32fa33545/image.png)


## 풀이 2. 스택 쌓기

![](https://velog.velcdn.com/images/soheelog/post/3c1acff4-702c-4bf2-94b4-217707e8e286/image.png)

스택을 사용하여 풀어보자. 
스택을 쌓으면서 현재 높이가 이전 높이보다 높을 때, 즉 꺽이는 부분을 변곡점(Inflection Point)을 기준으로 격차만큼 물이 쌓이는 양 water를 채운다.
이전 높이는 변화할 수 있기 때문에 계속 스택으로 채워나가다가 변곡점을 만날 때 마다 스택에서 하나씩 꺼내면서 이전과의 차이만큼 물이 쌓이는 양을 채워나간다.
스택으로 이전 항목을 체크하긴 하지만 기본적으로 왼쪽에서 오른쪽으로 한번만 살펴보기 때문에 O(n)풀이가 가능하다. 그러나 실행시간는 투 포인터보다 더 오래 걸린다. 

` int waters = Math.min(height[i], height[stack.peek()]) - height[top];`코드는 현재 높이와 스택의 마지막 위치중에서 더 낮은 값에 방금 꺼낸 높이를 물 높이로 지정하고, `distance * waters`를 통해 물이 쌓인 양(거리*물높이)을 쌓아서 더해주었다.


```java
class Solution {
    public int trap(int[] height) {
        int water = 0;
        Deque<Integer> stack = new ArrayDeque<>();

        for (int i = 0; i < height.length; i++) {
            // 변곡점을 만나는 경우
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                // 스택에서 꺼낸다
                Integer top = stack.pop();

                if (stack.isEmpty()) {
                    break;
                }

                int distance = i - stack.peek() - 1;
                int waters = Math.min(height[i], height[stack.peek()]) - height[top];
                
                water += distance * waters;
            }
            stack.push(i);
        }
        
        return water;
    }
}
```
![](https://velog.velcdn.com/images/soheelog/post/f61c2f03-7435-489f-bd23-3cb8db3b484a/image.png)








