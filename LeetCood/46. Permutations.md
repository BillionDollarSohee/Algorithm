[리트코드 46. 순열](https://leetcode.com/problems/permutations/description/)

문제 : 서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하라 <br>
입력 : [1,2,4]<br>
출력 : [[1,2,4],[1,4,2],[2,1,4],[2,4,1],[4,1,2],[4,2,1]]<br>

## 자바풀이. DFS를 활용한 순열 생성
순열의 공식은 따로 설명하지 않겠다. <br>
예제의 경우에는 입력값의 순열의 수는 `3!/(3-3)!` 이므로 <br>
분자의 팩토리얼만 계산하면 `3! = 3 X 2 X 1 = 6` 이다. <br>
이렇게 개수를 구하는 것은 어렵지 않지만, <br>
모든 결과를 생성해야 하는 것은 조금 까다롭다. <br>
그래프로 표현하면 다음과 같다. <br>

<img width="524" height="276" alt="image" src="https://github.com/user-attachments/assets/68e79a16-193b-4c46-b35e-f80eb486518d" />

레벨이 증가할수록, 자식 노드의 개수가 점점 작아지는 규칙을 볼 수 있다. <br>
순열의 수식에서 `3 X 2 X 1` 의 형태와도 같다. <br>
만약 입력값이 5개라면 `5 X 4 X 3 X 2 X 1` 이고 순열의 수는 120개이다.<br>

```java
class Solution {
    public void dfs(List<List<Integer>> results, List<Integer> prevElements, List<Integer> elements) {
        // 리프 노드에 도달하면 결과에 추가
        if (elements.isEmpty()) {
            results.add(prevElements.stream()
                                   .collect(Collectors.toList()));
        }

        // 전달받은 엘리먼트를 모두 탐색
        for (Integer e : elements) {
            // 현재 엘리먼트를 제외하고 nextElements로 새롭게 구성
            List<Integer> nextElements = new ArrayList<>(elements);
            nextElements.remove(e);

            // pervElements에 현재 엘리먼트 추가
            prevElements.add(e);

            // 재귀 dfs
            dfs(results, prevElements, nextElements);

            // 돌아온 이후에 prevElements에서 현재 엘리먼트 삭제
            prevElements.remove(e);
        }
    }

    public List<List<Integer>> permute(int[] nums) {
        // 결과 리스트
        List<List<Integer>> results = new ArrayList<>();

        List<Integer> lst = Arrays.stream(nums).boxed().collect(Collectors.toList());
        dfs(results, new ArrayList<>(), lst);
        return results;
    }
}
```

<img width="692" height="453" alt="image" src="https://github.com/user-attachments/assets/929c86cb-f3bd-43d0-87be-5c41d70d9065" />

> boxed()는 IntStream 같은 기본형 스트림을 참조형 스트림으로 변환해주는 메소드이다. <br>
IntStream.boxed() 는 int → Integer 로 오토 박싱하여 IntStream → Stream<Integer>로 만들어준다. <br>

## 코틀린 풀이.
역시 중첩 함수로 파라미터를 3 -> 2개로 줄일 수 있다.

```kotlin
class Solution {
    fun permute(nums: IntArray): List<List<Int>> {
        val results: MutableList<List<Int>> = mutableListOf()

        fun dfs (prevElements: MutableList<Int>, elements: List<Int>) {
            // 리프 노드에 도달하면 결과에 추가
            if (elements.isEmpty()) {
                results.add(prevElements.stream().collect(Collectors.toList()))
            }

            for (e in elements) {
                // 현재 엘리먼트 제외한 nextElements 새롭게 구성
                val nextElements: MutableList<Int> = ArrayList(elements)
                nextElements.remove(e)

            // prevElements에 현재 엘리먼트 추가
            prevElements.add(e)

            dfs (prevElements, nextElements)

            // 돌아온 이후에 현재 엘리먼트 삭제
            prevElements.remove(e)
            }
        }

        val lst = Arrays.stream(nums).boxed().collect(Collectors.toList())
        dfs (mutableListOf(), lst)
        return results
    }
}
```

<img width="687" height="441" alt="image" src="https://github.com/user-attachments/assets/dac55379-5a8e-4ce2-8974-6f39256d6337" />
