[리트코드 561 - 배열 파티션1](https://leetcode.com/problems/array-partition/description/)

문제 n개의 페어를 이용한 min(a, b)의 합으로 만들 수 있는 가장 큰 수를 출력하라

입력 : [1, 3, 4, 2]
출력 : 4

입력에서 나올 수 있는 경우를 모두 만들어보면
1. min(1, 4) + min(2, 3) = 3
2. min(1, 3) + min(2, 4) = 3
3. min(1, 2) + min(3, 4) = 4
   
정렬을 해서 [1, 2, 3, 4]로 만든 후에 2개씩 min()을 하는 것이 가장 크다는 것을 알 수 있다. 

## 자바 풀이 1. 오름차순으로 정렬 후 min()을 합산

```java
class Solution {
    public int arrayPairSum(int[] nums) {
        int sum = 0;
        List<Integer> pair = new ArrayList<>();
        Arrays.sort(nums);

        for (int n : nums) {
            pair.add(n);

            if(pair.size() == 2) {
                sum += Collections.min(pair);
                pair.clear();
            }
        }

        return sum;
    }
}
```

<img width="678" height="442" alt="image" src="https://github.com/user-attachments/assets/ea760448-d419-4dec-b7cf-b83d04922f82" />

풀리긴 하지만 성능이 매우 낮은 것을 확인할 수 있다.

## 자바 풀이 2. 오름차순으로 정렬 후 짝수만 더하기
일일이 min()을 구하지 않더라도 짝수 번째 인덱스를 더해도 동일한 결과를 얻을 수 있다.

```java
class Solution {
    public int arrayPairSum(int[] nums) {
        int sum = 0;
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++) {
            if(i % 2 == 0) {
                sum += nums[i];
            }
        }

        return sum;
    }
}
```

<img width="681" height="440" alt="image" src="https://github.com/user-attachments/assets/ad57f0dd-32c1-468e-a93d-dcce056f96bf" />

성능이 조금 더 좋아졌다.

## 코틀린 풀이. 오름차순으로 정렬 후 짝수만 더하기
코틀린에서는 자료형이 모두 참조형이기 때문에 바로 `sort()`를 사용할 수 있다.
또한 파이썬의 `enumerate()` 처럼 `withIndex()`를 부여하면 인덱스와 값을 동시에 추출할 수 있다.


```kotlin
class Solution {
    fun arrayPairSum(nums: IntArray): Int {
        var sum = 0
        nums.sort();

        for ((i ,n) in nums.withIndex()) {
            if (i % 2 == 0) {
                sum += n
            }
        }

        return sum
    }
}
```


