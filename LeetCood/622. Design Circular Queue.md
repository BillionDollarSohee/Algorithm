[리트코드 622. - 링 버퍼 디자인](https://leetcode.com/problems/design-circular-queue/description/)

문제 : 원형큐를 디자인 하라. 큐가 비어있다면 -1을 리턴하며, 해당 원형 큐의 사용 예시는 다음과 같다.

```java
MyCircularQueue myCircularQueue = new MyCircularQueue(3);
myCircularQueue.enQueue(1); // return True
myCircularQueue.enQueue(2); // return True
myCircularQueue.enQueue(3); // return True
myCircularQueue.enQueue(4); // return False
myCircularQueue.Rear();     // return 3
myCircularQueue.isFull();   // return True
myCircularQueue.deQueue();  // return True
myCircularQueue.enQueue(4); // return True
myCircularQueue.Rear();     // return 4
myCircularQueue.front();    // return 2

초기: []
enQueue(1) → [1]
enQueue(2) → [1, 2]
enQueue(3) → [1, 2, 3] (꽉 참)
enQueue(4) → 실패, 그대로 [1, 2, 3]
Rear() → 3
isFull() → true
deQueue() → [2, 3] (1 제거)
enQueue(4) → [2, 3, 4]
Rear() → 4
front() → 2
```

## 자바 풀이. 배열을 이용하여 구현
배열로 링버퍼를 구현할 경우 공간을 재활용한다는 원형의 이점을 내세울 수 있다.
초기화 할 때 큐의 크기 k를 입력 받아 배열을 생성하고 front 포인터는 0, rear 포인터는 한칸 더 뒤인 -1에서 시작한다.
enQueue()를 할 때, 맨 처음에는 초기값이 -1 이였기 때문에 인덱스 0에 넣게 된다. 또한 전체길이 만큼 나머지로 모듈연산을 하므로 
포인터의 위치가 배열을 벗어나지 않게 한다.

리트코드 문제에서는 deQueue() 연산에서 엘리먼트를 꺼내지 않고 삭제만 수행하도록 되어있다.
큐에서 엘리먼트를 꺼내는 것은 앞쪽은 front(), 뒤쪽은 rear()로, 서로 각기 다른 연산으로 정의되어 있다.
다소 특이하지만 원래 큐 추상 자료형인 deQueue()에서는 삭제뿐만 아니라 추출도 함께 수행하므로 혼동하지 않아야 한다.
어쨌든 이문제에서는 삭제만을 요구하므로 간략하게 구현했다.

또한 문제와 달리 원래 큐에서는 Rear()연산이 없다.
큐는 맨앞에 있는 데이터를 가져오는 front()와 peek()만 정의되어 있다.
그러나 원형큐에서는 Rear()를 구현하는 것이 그리 어렵지 않으므로 문제에 맞춰서 구현했다.
(데크는 앞뒤모두 추출할 수 있는 연산을 정의하고 있다.)

`front`와 `rear` 인덱스를 `%` 연산으로 순환시키며, `len`으로 현재 요소 개수를 추적한다.  
`enQueue()`는 큐가 꽉 차지 않았을 때 값을 넣고 `rear`를 이동한다.  
`deQueue()`는 큐가 비어 있지 않을 때 `front`를 이동해 맨 앞 값을 제거한다.  
`Front()`/`Rear()`는 각각 현재 맨 앞과 맨 뒤 값을 반환하며, 비어 있으면 -1을 반환한다.  

```java
class MyCircularQueue {
    int[] q;
    int front = 0;
    int rear = -1;
    int len = 0;

    public MyCircularQueue(int k) {
        this.q = new int[k];
    }
    
    public boolean enQueue(int value) {
        if (!this.isFull()) { // 가득 차 있지 않다면 넣기
            this.rear = (this.rear + 1) % this.q.length;
            this.q[rear] = value;
            this.len++;
            return true;
        } else {
            return false;
        }
    }
    
    public boolean deQueue() {
        if (!this.isEmpty()) { // 비어있지 않다면
            this.front = (this.front + 1) % this.q.length;
            this.len--;
            return true;
        } else {
            return false;
        }
    }
    
    public int Front() {
        return (this.isEmpty()) ? -1 : this.q[this.front];
    }
    
    public int Rear() {
        return (this.isEmpty()) ? -1 : this.q[this.rear];
    }
    
    public boolean isEmpty() {
        return this.len == 0;
    }
    
    public boolean isFull() {
        return this.len == this.q.length;
    }
}
```

<img width="681" height="437" alt="image" src="https://github.com/user-attachments/assets/3bfc7214-b12d-4ec3-9755-a7e2e8af5c11" />

## 코틀린 풀이  


```kotlin
class MyCircularQueue(k: Int) {
    var q: IntArray = IntArray(k)
    var front = 0
    var rear = -1
    var len = 0

    fun enQueue(value: Int): Boolean {
        return if (!isFull()) {
            this.rear = (this.rear + 1) % this.q.size
            this.q[rear] = value
            this.len++
            true
        } else
            false
    }

    fun deQueue(): Boolean {
        return if (!this.isEmpty()) {
            this.front = (this.front + 1) % this.q.size
            this.len--
            true
        } else 
            false
    }

    fun Front(): Int {
        return if (this.isEmpty())
            -1
        else
            q[front]
    }

    fun Rear(): Int {
        return if (this.isEmpty())
            -1
        else
            q[this.rear]
    }

    fun isEmpty(): Boolean {
        return this.len == 0
    }

    fun isFull(): Boolean {
        return this.len == this.q.size
    }

}
```

<img width="680" height="440" alt="image" src="https://github.com/user-attachments/assets/fa3d8c06-3452-47dc-8600-b44cb30d376e" />



