[리트코드 641. 원형 데크 디자인](https://leetcode.com/problems/design-circular-deque/description/)

문제 : 다음 연산을 제공하는 원형 데크를 디자인하라.

- MyCircularDeque(int k) : 데크 크기를 k로 지정하는 생성자이다.
- boolean insertFront() : Deque의 맨 앞에 항목을 추가합니다. (true/false)
- boolean insertLast() : Deque 뒤에 항목을 추가합니다. (true/false)
- boolean deleteFront() : Deque의 앞쪽에서 항목을 삭제합니다. (true/false)
- boolean deleteLast() : Deque 뒤쪽에서 항목을 삭제합니다. (true/false)
- int getFront() : Deque에서 맨 앞 항목을 반환합니다. (value/-1)
- int getRear() : Deque의 마지막 항목을 반환합니다. (value/-1)
- boolean isEmpty() : 데크가 비어 있는지 여부를 반환합니다 (true/false)
- boolean isFull() : 데크가 가득 찼는지 여부 를 반환합니다 (true/false)

## 자바 풀이. 이중 연결 리스트를 이용한 데크 구현
자바에서 연결리스트는 이미 이중연결리스트 이므로 바로 사용하면 되지만,
직접 구현을 해보기 위해 DoublyLinkedList란 이름으로 클래스를 직접 선언했다.
이 클래스는 문제 풀이 클래스의 중첩클래스(Nested class)로 선언할 것이며,
이에따라 static으로 선언했다.

```java
class MyCircularDeque {

    static class DoublyLinkedList {
        DoublyLinkedList left;
        DoublyLinkedList right;
        int val;

        public DoublyLinkedList(int val) {
            this.val = val;
        }
    }

    int k;                 // 전체 큐의 크기
    int len;               // 현재 큐의 크기
    DoublyLinkedList head; // head Node
    DoublyLinkedList tail; // tail Node

    public MyCircularDeque(int k) {
        head = new DoublyLinkedList(0);
        tail = new DoublyLinkedList(0);

        this.k = k;
        this.len = 0;

        // 서로 연결
        head.right = tail;
        tail.left = head;
    }
    
    public boolean insertFront(int value) {
        if (isFull()) { // 가득 차 있으면 진행하지 않음
            return false;
        } 

        // 신규 노드는 head의 오른쪽에 삽입
        DoublyLinkedList node = new DoublyLinkedList(value);
        node.right = head.right;
        node.left = head;
        head.right.left = node;
        head.right = node;
        len++;
        return true;
    }
    
    public boolean insertLast(int value) {
        if (isFull()) { // 가득 차 있으면 진행하지 않음
            return false;
        } 

        // 신규 노드는 tail의 왼쪽에 삽입
        DoublyLinkedList node = new DoublyLinkedList(value);
        node.left = tail.left;
        node.right = tail;
        tail.left.right = node;
        tail.left = node;
        len++;
        return true;
    }
    
    public boolean deleteFront() {
        if (isEmpty()) { // 텅 비어있으면 진행하지 않음
            return false;
        }

        // head 바로 오른쪽 노드를 연결에서 끊음
        DoublyLinkedList node = head.right;  // 삭제할 마지막 노드
        head.right = node.right;
        node.right.left = head;
        len--;
        return true;
    }
    
    public boolean deleteLast() {
        if (isEmpty()) { // 텅 비어있으면 진행하지 않음
            return false;
        }

        // tail 바로 왼쪽 노드를 연결에서 끊음
        DoublyLinkedList node = tail.left;   // 삭제할 마지막 노드
        tail.left = node.left;               // tail 왼쪽을 삭제할 노드의 왼쪽으로 연결
        node.left.right = tail;              // 삭제할 노드의 왼쪽 노드가 tail을 가리키도록 연결
        len--;
        return true;
    }
    
    public int getFront() {
        return (isEmpty()) ? -1 : head.right.val;
    }
    
    public int getRear() {
        return (isEmpty()) ? -1 : tail.left.val;
    }
    
    public boolean isEmpty() {
        return len == 0;
    }
    
    public boolean isFull() {
        return len == k;
    }
}
```
<img width="674" height="439" alt="image" src="https://github.com/user-attachments/assets/880e2d9e-047e-433e-a4f1-c4818deed991" />


## 코틀린 풀이
```kotlin

```
