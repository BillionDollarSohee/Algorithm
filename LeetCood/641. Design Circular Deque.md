[리트코드 641. 원형 데크 디자인](https://leetcode.com/problems/design-circular-deque/description/)

문제 : 다음 연산을 제공하는 원형 데크를 디자인하라.

- MyCircularDeque(int k) : 데크 크기를 k로 지정하는 생성자이다.
- boolean insertFront() : Deque의 맨 앞에 항목을 추가합니다. (true/false)
- boolean insertLast() : Deque 뒤에 항목을 추가합니다. (true/false)
- boolean deleteFront() : Deque의 앞쪽에서 항목을 삭제합니다. (true/false)
- boolean deleteLast() : Deque 뒤쪽에서 항목을 삭제합니다. (true/false)
- int getFront() : Deque에서 맨 앞 항목을 반환합니다. (value/-1)
- int getRear() : Deque의 마지막 항목을 반환합니다. (value/-1)
- boolean isEmpty() : 데크가 비어 있는지 여부를 반환합니다 (true/false)
- boolean isFull() : 데크가 가득 찼는지 여부 를 반환합니다 (true/false)

## 자바 풀이. 이중 연결 리스트를 이용한 데크 구현
자바에서 연결리스트는 이미 이중연결리스트 이므로 바로 사용하면 되지만,
직접 구현을 해보기 위해 DoublyLinkedList란 이름으로 클래스를 직접 선언했다.
이 클래스는 문제 풀이 클래스의 중첩클래스(Nested class)로 선언할 것이며,
이에따라 static으로 선언했다.

그런데 사실 

```java
class MyCircularDeque {
    int k;                 // 전체 큐의 크기
    int len;               // 현재 큐의 크기
    DoublyLinkedList head; // head Node
    DoublyLinkedList tail; // tail Node

    static class DoublyLinkedList { // 생성자
        DoublyLinkedList left;
        DoublyLinkedList right;
        int val;

        public DoublyLinkedList(int val) {
            this.val = val;
        }
    }

    public MyCircularDeque(int k) {
        head = new DoublyLinkedList(0);
        tail = new DoublyLinkedList(0);

        this.k = k;
        this.len = 0;

        // 서로 연결
        head.right = tail;
        tail.left = head;
    }
    
    public boolean insertFront(int value) {
        if (isFull()) { // 가득 차 있으면 진행하지 않음
            return false;
        } 

        // 신규 노드는 head의 오른쪽에 삽입
        DoublyLinkedList node = new DoublyLinkedList(value);
        node.right = head.right;
        node.left = head;
        head.right.left = node;
        head.right = node;
        len++;
        return true;
    }
    
    public boolean insertLast(int value) {
        if (isFull()) { // 가득 차 있으면 진행하지 않음
            return false;
        } 

        // 신규 노드는 tail의 왼쪽에 삽입
        DoublyLinkedList node = new DoublyLinkedList(value);
        node.left = tail.left;
        node.right = tail;
        tail.left.right = node;
        tail.left = node;
        len++;
        return true;
    }
    
    public boolean deleteFront() {
        if (isEmpty()) { // 텅 비어있으면 진행하지 않음
            return false;
        }

        // head 바로 오른쪽 노드를 연결에서 끊음
        DoublyLinkedList node = head.right;  // 삭제할 마지막 노드
        head.right = node.right;
        node.right.left = head;
        len--;
        return true;
    }
    
    public boolean deleteLast() {
        if (isEmpty()) { // 텅 비어있으면 진행하지 않음
            return false;
        }

        // tail 바로 왼쪽 노드를 연결에서 끊음
        DoublyLinkedList node = tail.left;   // 삭제할 마지막 노드
        tail.left = node.left;               // tail 왼쪽을 삭제할 노드의 왼쪽으로 연결
        node.left.right = tail;              // 삭제할 노드의 왼쪽 노드가 tail을 가리키도록 연결
        len--;
        return true;
    }
    
    public int getFront() {
        return (isEmpty()) ? -1 : head.right.val;
    }
    
    public int getRear() {
        return (isEmpty()) ? -1 : tail.left.val;
    }
    
    public boolean isEmpty() {
        return len == 0;
    }
    
    public boolean isFull() {
        return len == k;
    }
}
```
<img width="674" height="439" alt="image" src="https://github.com/user-attachments/assets/880e2d9e-047e-433e-a4f1-c4818deed991" />


## 코틀린 풀이
코틀린은 이중 연결 리스트 선언 부분이 자바와 조금 다르다.
자바와 달리 생성자를 생략해도 되고, 클래스의 파라미터를 부여할 수도 있어서 편하다.
코틀린은 기본적으로 중첩클래스로 선언되기 때문에 `static` 키워드를 사용하지 않으며,
오히려 내부클래스가 되려면 `inner`로 선언해야하므로 자바와 정 반대의 방식이라고 볼 수 있다.
대개는 서로 의존성이 없고, 성능을 더 높일 수 있는 중첩클래스를 더 흔하게 사용하기 때문에
코틀린에서는 따로 선언하지 않아도 되며, 이중 연결 리스트 선언이 간결해졌다.

생성자를 코틀린에선 `init`키워드로 초기화 블록으로 제공한다.
또한 left와 right를 선언하는 형식에서 널 허용으로 선언되어 있는데,
따라서 매번 널 처리 여부를 명시해주어야한다.
그런데 여기서는 null인 경우 문제풀이가 안되므로 널처리를 생략하고 편의상 `!!`로 처리했다.
실무에서는 NPE를 방지하려면 반드시 널 처리가 필요하므로 주의해야한다.

그런데 아래와 같은 에러가 발생했다. nullable (?) 타입 처리 문제 + 메서드 참조 문제 때문에 터지는 것 같다.
```
Line 15: Char 13: ERROR: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type 'MyCircularDeque.DoublyLinkedList?'.
Line 16: Char 13: ERROR: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type 'MyCircularDeque.DoublyLinkedList?'.
Line 20: Char 13: ERROR: Unresolved reference 'isFull'.
Line 23: Char 26: ERROR: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type 'MyCircularDeque.DoublyLinkedList?'.
Line 25: Char 13: ERROR: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type 'MyCircularDeque.DoublyLinkedList?'.
Line 26: Char 13: ERROR: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type 'MyCircularDeque.DoublyLinkedList?'.
```
따라서 head 와 tail 은 절대 null 이 아니게 init 블록에서 초기화하게끔 코드를 대폭 수정했다.


```kotlin
class MyCircularDeque(private val k: Int) {
    private var len = 0
    private var head: DoublyLinkedList
    private var tail: DoublyLinkedList

    data class DoublyLinkedList(var value: Int) {
        var left: DoublyLinkedList? = null
        var right: DoublyLinkedList? = null
    }

    init {
        head = DoublyLinkedList(0)
        tail = DoublyLinkedList(0)
        head.right = tail
        tail.left = head
    }

    fun insertFront(value: Int): Boolean {
        if (isFull()) return false
        val node = DoublyLinkedList(value)
        node.right = head.right
        node.left = head
        head.right!!.left = node
        head.right = node
        len++
        return true
    }

    fun insertLast(value: Int): Boolean {
        if (isFull()) return false
        val node = DoublyLinkedList(value)
        node.left = tail.left
        node.right = tail
        tail.left!!.right = node
        tail.left = node
        len++
        return true
    }

    fun deleteFront(): Boolean {
        if (isEmpty()) return false
        val node = head.right!!
        head.right = node.right
        node.right!!.left = head
        len--
        return true
    }

    fun deleteLast(): Boolean {
        if (isEmpty()) return false
        val node = tail.left!!
        tail.left = node.left
        node.left!!.right = tail
        len--
        return true
    }

    fun getFront(): Int {
        return if (isEmpty()) -1 else head.right!!.value
    }

    fun getRear(): Int {
        return if (isEmpty()) -1 else tail.left!!.value
    }

    fun isEmpty(): Boolean = len == 0
    fun isFull(): Boolean = len == k
}
```

<img width="682" height="442" alt="image" src="https://github.com/user-attachments/assets/92553b9c-052c-424f-92cc-a2a4bc0398d3" />

