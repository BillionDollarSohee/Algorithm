아래처럼 줄바꿈/개행 정리해서 붙여쓰면 그대로 예쁘게 보여질 거예요
(불필요한 끊김/깨짐 제거 + 문장 텀 확보)

---

[리트코드 706. 해시맵디자인](https://leetcode.com/problems/design-hashmap/description/)

문제 : 다음과 같은 기능을 제공하는 해시맵을 디자인하라.

* put(key, value) : 키, 값을 해시맵에 삽입한다. 만약 이미 존재하는 키라면 업데이트한다.
* get(key) : 키에 해당하는 값을 조회한다. 만약 키가 존재하지 않으면 -1을 리턴한다.
* remove(key) : 키에 해당하는 키, 값을 해시맵에서 삭제한다.

입력 :

```
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]  
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
```

출력 :

```
[null, null, null, 1, -1, null, 1, null, -1]
```

예시 :

```
MyHashMap myHashMap = new MyHashMap(); 

myHashMap.put(1, 1);  // 맵은 이제 [[1,1]]
myHashMap.put(2, 2);  // 맵은 이제 [[1,1], [2,2]]

myHashMap.get(1);     // 1 반환,   [[1,1], [2,2]]
myHashMap.get(3);     // -1 반환,  [[1,1], [2,2]]

myHashMap.put(2, 1);  // 기존 값 업데이트 → [[1,1], [2,1]]

myHashMap.get(2);     // 1 반환

myHashMap.remove(2);  // [[1,1]]

myHashMap.get(2);     // -1 반환
```

---

## 자바풀이 개념 설명

내가 만들 해시맵 구조를 쉽게 말하자면

“큰 배열 하나를 만들어 놓고,
key 값을 이용해서 그 배열의 특정 칸으로 바로 찾아가서 value 를 보관하는 방식” 을 구현하는 것이다.

하지만 key 가 몇 개 들어올지 모르니까
배열을 아주 크게 미리 선언해 둔다. (예: 10000칸짜리)

다음으로, key 를 배열 index 로 그대로 쓰는게 아니라
해싱을 위해 `key % 배열길이` 를 해서 `index` 를 만든다.

같은 index 로 몰리는 충돌이 생길 수 있고,
이 충돌은 **개별 체이닝 방식(= 연결리스트)** 으로 처리한다.
즉 같은 칸에 Node 들을 줄지어 연결해 둔다.

```java
class MyHashMap {
    static class Node {
        int key, val;
        Node next;

        Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }

    final Node[] nodes = new Node[1000000];

    public void put(int key, int value) {
        int index = key % nodes.length;

        if (nodes[index] == null) {
            nodes[index] = new Node(key, value);
            return;
        }

        Node node = nodes[index];
        while (node != null) {
            if (node.key == key) {
                node.val = value;
                return;
            }
            if (node.next == null) break;
            node = node.next;
        }

        node.next = new Node(key, value);
    }

    public int get(int key) {
        int index = key % nodes.length;

        if (nodes[index] == null) return -1;

        Node node = nodes[index];
        while (node != null) {
            if (node.key == key) return node.val;
            node = node.next;
        }
        return -1;
    }

    public void remove(int key) {
        int index = key % nodes.length;

        Node node = nodes[index];
        if (node == null) return;

        // 첫 노드가 대상인 경우
        if (node.key == key) {
            nodes[index] = node.next;
            return;
        }

        Node prev = node;
        node = node.next;

        while (node != null) {
            if (node.key == key) {
                prev.next = node.next;
                return;
            }
            prev = node;
            node = node.next;
        }
    }
}
```

<img width="687" height="443" alt="image" src="https://github.com/user-attachments/assets/9273ae82-76c5-431a-81ff-4ef548a8125c" />


---

## 코틀린 풀이

```kotlin
// 너무 졸리다 미완
```

