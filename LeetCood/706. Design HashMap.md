[리트코드 706. 해시맵디자인](https://leetcode.com/problems/design-hashmap/description/)

문제 : 다음과 같은 기능을 제공하는 해시맵을 디자인하라.

* put(key, value) : 키, 값을 해시맵에 삽입한다. 만약 이미 존재하는 키라면 업데이트한다.
* get(key) : 키에 해당하는 값을 조회한다. 만약 키가 존재하지 않으면 -1을 리턴한다.
* remove(key) : 키에 해당하는 키, 값을 해시맵에서 삭제한다.

입력 :

```
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]  
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
```

출력 :

```
[null, null, null, 1, -1, null, 1, null, -1]
```

예시 :

```
MyHashMap myHashMap = new MyHashMap(); 

myHashMap.put(1, 1);  // 맵은 이제 [[1,1]]
myHashMap.put(2, 2);  // 맵은 이제 [[1,1], [2,2]]

myHashMap.get(1);     // 1 반환,   [[1,1], [2,2]]
myHashMap.get(3);     // -1 반환,  [[1,1], [2,2]]

myHashMap.put(2, 1);  // 기존 값 업데이트 → [[1,1], [2,1]]

myHashMap.get(2);     // 1 반환

myHashMap.remove(2);  // [[1,1]]

myHashMap.get(2);     // -1 반환
```

---

## 자바풀이 개념 설명

내가 만들 해시맵 구조를 쉽게 말하자면

“큰 배열 하나를 만들어 놓고,
key 값을 이용해서 그 배열의 특정 칸으로 바로 찾아가서 value 를 보관하는 방식” 을 구현하는 것이다.

하지만 key 가 몇 개 들어올지 모르니까
배열을 아주 크게 미리 선언해 둔다. (예: 10000칸짜리)

다음으로, key 를 배열 index 로 그대로 쓰는게 아니라
해싱을 위해 `key % 배열길이` 를 해서 `index` 를 만든다.

같은 index 로 몰리는 충돌이 생길 수 있고,
이 충돌은 **개별 체이닝 방식(= 연결리스트)** 으로 처리한다.
즉 같은 칸에 Node 들을 줄지어 연결해 둔다.

```java
class MyHashMap {
    static class Node {
        int key, val;
        Node next;

        Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }

    final Node[] nodes = new Node[1000000];

    public void put(int key, int value) {
        int index = key % nodes.length;

        if (nodes[index] == null) {
            nodes[index] = new Node(key, value);
            return;
        }

        Node node = nodes[index];
        while (node != null) {
            if (node.key == key) {
                node.val = value;
                return;
            }
            if (node.next == null) break;
            node = node.next;
        }

        node.next = new Node(key, value);
    }

    public int get(int key) {
        int index = key % nodes.length;

        if (nodes[index] == null) return -1;

        Node node = nodes[index];
        while (node != null) {
            if (node.key == key) return node.val;
            node = node.next;
        }
        return -1;
    }

    public void remove(int key) {
        int index = key % nodes.length;

        Node node = nodes[index];
        if (node == null) return;

        // 첫 노드가 대상인 경우
        if (node.key == key) {
            nodes[index] = node.next;
            return;
        }

        Node prev = node;
        node = node.next;

        while (node != null) {
            if (node.key == key) {
                prev.next = node.next;
                return;
            }
            prev = node;
            node = node.next;
        }
    }
}
```

<img width="687" height="443" alt="image" src="https://github.com/user-attachments/assets/9273ae82-76c5-431a-81ff-4ef548a8125c" />


---

## 코틀린 풀이 (실패)

```kotlin
class MyHashMap() {

    class Node(var key: Int, var value: Int) {
        var next: Node? = null
    }

    private val size = 2_000_003  // 소수 (충돌 최소화)
    private val nodes = arrayOfNulls<Node>(size)

    fun put(key: Int, value: Int) {
        val idx = key % size
        var node = nodes[idx]

        if (node == null) {
            nodes[idx] = Node(key, value)
            return
        }

        var prev: Node? = null
        while (node != null) {
            if (node.key == key) {
                node.value = value
                return
            }
            prev = node
            node = node.next
        }
        prev!!.next = Node(key, value)
    }

    fun get(key: Int): Int {
        val idx = key % size
        var node = nodes[idx] ?: return -1

        while (node != null) {
            if (node.key == key) return node.value
            node = node.next
        }
        return -1
    }

    fun remove(key: Int) {
        val idx = key % size
        var node = nodes[idx] ?: return

        if (node.key == key) {
            nodes[idx] = node.next
            return
        }

        var prev = node
        node = node.next

        while (node != null) {
            if (node.key == key) {
                prev.next = node.next
                return
            }
            prev = node
            node = node.next
        }
    }
}

```

<img width="927" height="228" alt="image" src="https://github.com/user-attachments/assets/907c7a3f-8e19-47d1-9679-9d4a4157131c" /> <br>
왜안되는건지 나로서는 이해가 안간다.

## 코틀린 배열 풀이 (실패)
```kotlin
class MyHashMap() {

    private val arr = IntArray(1_000_001) { -1 }

    fun put(key: Int, value: Int) {
        arr[key] = value
    }

    fun get(key: Int): Int {
        return arr[key]
    }

    fun remove(key: Int) {
        arr[key] = -1
    }
}
```

<img width="683" height="447" alt="image" src="https://github.com/user-attachments/assets/eee97c04-23eb-4bf7-99b8-af29dd0ef5b6" /> <br>
이건 또 합격 목걸이를 준다. <br>
실패했던 코드는 “Node? (nullable)” 흐름을 코틀린 컴파일러가 안전하다고 증명 못해서 막힌 것이고, <br>
배열 코드는 null 이 없으니 애초에 증명 문제 자체가 없어서 통과한 것 같다.<br>

## 챗 지피티가 풀어준 코틀린 풀이

```kotlin
class MyHashMap {

    private class Node(val key: Int, var value: Int, var next: Node?)

    private val size = 2_000_003 // 큰 소수 버킷: 충돌 감소용
    private val buckets = arrayOfNulls<Node>(size)

    fun put(key: Int, value: Int) {
        val idx = key % size
        val head = buckets[idx]
        if (head == null) {
            buckets[idx] = Node(key, value, null)
            return
        }

        var cur: Node? = head
        while (cur != null) {
            val node = cur           // <- 여기서 non-null 로 섀도잉
            if (node.key == key) {
                node.value = value
                return
            }
            if (node.next == null) { // 끝에 도달: 새 노드 연결
                node.next = Node(key, value, null)
                return
            }
            cur = node.next
        }
    }

    fun get(key: Int): Int {
        val idx = key % size
        var cur = buckets[idx]
        while (cur != null) {
            val node = cur           // non-null 섀도잉
            if (node.key == key) return node.value
            cur = node.next
        }
        return -1
    }

    fun remove(key: Int) {
        val idx = key % size
        val head = buckets[idx] ?: return

        // 첫 노드가 대상
        if (head.key == key) {
            buckets[idx] = head.next
            return
        }

        var prev: Node = head
        var cur: Node? = head.next
        while (cur != null) {
            val node = cur           // non-null 섀도잉
            if (node.key == key) {
                prev.next = node.next
                return
            }
            prev = node
            cur = node.next
        }
    }
}

```

<img width="686" height="448" alt="image" src="https://github.com/user-attachments/assets/027606f2-ff19-4141-a2de-afda0d94320b" />


