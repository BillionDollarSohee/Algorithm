[리트코드 706. 해시맵디자인](https://leetcode.com/problems/design-hashmap/description/)

문제 : 다음과 같은 기능을 제공하는 해시맵을 디자인하라.
- put(key, value) : 키, 값을 해시맵에 삽입한다. 만약 이미 존재하는 키라면 업데이트한다.
- get(key) : 키에 해당하는 값을 조회한다. 만약 키가 존재하지 않으면 -1을 리턴한다.
- remove(key) : 키에 해당하는 키, 값을 해시맵에서 삭제한다.

입력 : 
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]

출력 : 
[null, null, null, 1, -1, null, 1, null, -1]

예시 : 
MyHashMap myHashMap = new MyHashMap(); 
myHashMap.put(1, 1); // 맵은 이제 [[1,1]]입니다 
myHashMap.put(2, 2); // 맵은 이제 [[1,1], [2,2]]입니다 
myHashMap.get(1); // 1을 반환합니다. 맵은 이제 [[1,1], [2,2]]입니다 
myHashMap.get(3); // 완)
```

## 자바풀이.
내가 만들 해시맵 구조를 쉽게 말하자면

“큰 배열 하나를 만들어 놓고,
key 값을 이용해서 그 배열의 특정칸에 바로 찾아가서 값(value)을 보관하는 방식” 을 구현하는 것이다.

근데 문제는 우리가 나중에 넣을 key 가 몇인지 미리 모르니까 배열을 아주 크게 선언해놓을 것이다.
(예: 10000 칸짜리 배열)

그 다음에 key 를 배열에 그대로 index 로 쓰는게 아니라
해싱을 위해 `key % 배열길이` 를 해서 `index` 로 만든다.

같은 index 로 몰리는 충돌이 생길 수 있다.
충돌은 개별체이닝방식 (=연결리스트에 추가하는방식) 으로 처리한다.


```
```

## 코틀린 풀이.
```
```
